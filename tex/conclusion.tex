\chapter{Conclusion and Recommendations}\label{cha:conclusion}
Overall, this thesis started by drawing a portrait of the \gls{BBPSim} software-in-the-loop platform's requirements and architecture. The relevant simulation modules and their functional behavior were explained in order to guide the literature review. 

After, three existing snapshotting solutions implemented in modern software were investigated: VirtualBox, \gls{CRIU} and the C\textsuperscript{3} source-to-source pre-compiler. It was shown that the saving and restoring operations could take place on multiple levels, that each came with their own pros and cons. Throughout the rest of the thesis, some of these concepts were reused and adapted to fit the context.

Since this project was integrated in the Dream Chaser development team at \gls{MDA}, a brief overview of the project management side was also given. A division into phases was done to ensure the iterative development of the feature in clear, milestone-driven increments. Furthermore, the work was also guided by feedback, both from the customer and MDA.

Once multiple checkpointing artifact formats were relatively weighed for their pros and cons, the most flexible one was chosen for the thesis' custom snapshotting feature. Subsequently, it was possible to identify the relevant items from the flight software to put in that artifact. This was done by analyzing the code, and then defining a set of necessary conditions that ensured FSW stability when restoring. Then, by taking advantage of the control given over the BBPSim build process, it was possible to deduce the runtime address of file-private variables belonging to DAS without having to modify its code. The manipulation involved the inclusion of a symbol catalog in BBPSim by linking its constituent object files twice. As for the execution of the threads, it was demonstrated that checkpointing the code was done using code injection and that the restoring of the execution via a careful stack frame overwrite was possible. It should be noted that the current implementation was not developed with portability in mind, and thus the restoring strategy is not guaranteed to work with another architecture or compiler.

Once the flight software could be correctly saved and restored, the alterable OS and hardware layers in BBPSim could be checkpointed using a builder-like Environment Saver, in combination with a block-iterating Environment Restorer when restoring. A general step-by-step recipe for defining the mandatory member variables of simulation modules to be included in a checkpointing artifact was also devised. 

Once the development was finished, it was also seen that the general performance of the save and restore feature surpassed the customer's constraints by a large margin. The feature fulfilled each one of the initial customer and user requirements.

To continue the work done in the thesis, their are multiple areas that could be improved or further investigated. For example, since the restoring techniques relied on the fact that the \gls{ASLR} of the Linux environment was disabled, one could think of the development of another technique that removes that limitation. With careful manipulation of \gls{VMA} sections in the process address range, it might be possible to make the \pathmono{libBbpSim.so} library load itself at the same address at every run. This would involve the  remapping of blocks of memory at runtime using low-level Linux calls (\texttt{mmap} and \texttt{munmap}). 

Another noteworthy avenue of study would be to make the restore feature backwards-compatible with previous versions of the checkpointing artifact, since it was tagged with both flight software and BBPSim versions.