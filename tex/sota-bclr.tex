\section{Berkeley Lab Checkpoint/Restart for Linux}\label{sec:blcr}
As mentioned throughout this chapter, the problem of checkpointing a computer program can be solved at multiple levels depending on the needs. The approach that was taken by VirtualBox is very powerful, but it has major drawbacks:
\begin{enumerate}
	\item \textbf{Overhead processing}. The fact that an entire system gets simulated implies that virtualizing an operating system with a type-2 hypervisor like VirtualBox is basically an overhead cost on executing the program. 
	\item \textbf{Granularity}. It checkpoints the whole computer's state instead of one program. This is often too much granularity and can result in very large snapshot files. In the case of \gls{BBPSim}, this would be quite excessive.
	\item \textbf{Dependence on an hypervisor}. If the execution of the program had to happen inside an virtualized operating system, a simulation of the \gls{BBP} would have to rely on the use of an hypervisor. This not desirable, especially for the client.
\end{enumerate}

However, some other techniques can circumvent these limitations by taking by using a differing degree of checkpointing transparency, that is, at which abstraction layer the checkpoint takes place. Walters and Chaudhary define those layers as follows: 
\begin{shadedquotation}
\begin{enumerate}
	\item Hardware-level, additional hardware is incorporated into the processor to
save state.
	\item Kernel-level, the operating system is primarily responsible for checkpointing
running programs.
	\item User-level, a checkpointing library is linked into a program that will be responsible for checkpointing the program independent of the programmer.
	\item Application-level, the checkpointing code is inserted directly into the application by a programmer/preprocessor.
\end{enumerate}
\cite{paper:app-level-chkpt}
\end{shadedquotation}

\gls{BLCR} is one those attempts at creating a user-friendly method for checkpointing a Linux program. It is a program implemented at the Kernel-level, meaning that it is a module add-on to the Linux kernel and should be installed prior to running the user application.

\subsection*{Overview}
\gls{BLCR}'s solution is completely different from the one seen in \autoref{sec:virtualbox}, where checkpointing happens for every program running in the guest OS. It bases itself on the fact that properly controlling a program in a sandbox makes it checkpointable. This sandbox is provided by a kernel daemon, another process that runs in background in the kernel, that knows how to execute a checkpoint on a given program. 
\begin{figure}[htbp]
	\centering \small
	\includesvg[width=0.75\textwidth]{svg/blcr}
	\caption{Abstraction layers for an application sandboxed by BLCR.}
	\label{fig:layerblcr}
\end{figure}

There are several different ways to use \gls{BLCR}. An application-centric use case is shown in \autoref{fig:layerblcr}. To access the required utilities to checkpoint itself, the application code needs to have access to the library at compile-time. At runtime, the library (\pathmono{BLCR.so}) is then dynamically linked to the application code and the kernel-based BLCR process is put in charge of managing the application process' resources via the dynamic library. This management layer is necessary to properly save the application.

Checkpointing a program is done is done via shell commands to the background-running BLCR daemon:
\begin{tcolorbox}
\begin{minted}{bash}
cr_checkpoint --pid <PID>
\end{minted}
\end{tcolorbox}

where \texttt{PID} is the process ID of the checkpointable application. This command can be called programatically by the running application (via a \texttt{system()} call in the code), by another program or even by the user itself. Thus, checkpoints are sporadic in that context.

Once those commands are initiated, the \gls{BLCR} daemon outputs a context file containing the relevant information to restart back the application at this stage. At restore, the user must restart the application from the saved context file with another shell command:
\begin{tcolorbox}
\begin{minted}{bash}
cr_restart <path_to_context>
\end{minted}
\end{tcolorbox}
This fully restores the old application state: virtual address space, registers, thread and process IDs, file descriptors, signals. Basically everything not related to sockets or serial ports is put back the way it was.

%https://crd.lbl.gov/departments/computer-science/class/research/past-projects/BLCR/
%- see also virtualization technology : https://github.com/dmtcp/dmtcp (process-based)
