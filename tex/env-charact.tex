{
\setlength{\parindent}{2em}
\chapter{Software Environment}\label{cha:sim-env}
Before proceeding to any design, it was important to first thoroughly characterize the setting in which the save \& restore was implemented. Fundamentally, this thesis was an integration project and, without a surprise, the checkpointing feature had to be merged coherently in the previously existing environment.

This chapter better describes the main driving factors in the design of the feature. From user and customer requirements to technical considerations, it serves as the basis on which everything was subsequently built.

\section{Requirements}
In the context of the \gls{DCCS}, Sierra Nevada Corporation subcontracted the entire design and implementation of the communications subsystem to \gls{MDA}. \gls{SNC} had clear goals with Dream Chaser, and for this multi-company undertaking to be properly organized, a hierarchical list of requirements had to be produced. The list was then given to the relevant subcontractors so they could guide themselves in the design of their subsystem. The final product could then be analyzed to assess how well it met the expectations. 

In the Dream Chaser program, the main product to be delivered by \gls{MDA} was the \gls{BBP} along with \gls{DAS}, its flight software. However, even though \gls{BBPSim} was treated as a sub-product to be delivered in conjunction, it also possessed its own set of requirement documents.

In the case of this thesis, two types of requirements were driving factors in the design, each with a different scope. Of course, the primary customer requirements from \gls{SNC} had to be followed, but another set was produced in parallel to provide additional guidelines to help the fulfillment of the feature.  

\subsection*{Customer Requirements}
\textit{Scope: the {BBPSim} framework.}

Throughout the thesis work, the customer requirements of the entire \gls{BBPSim} ecosystem were taken as the main drivers to follow for the development. As a measure of legal prudence, the integral list of requirements cannot be made available in this document. \autoref{tab:customer-reqs} lists several of them that relate to the development of the checkpointing feature.  
\begin{table}[htbp]
	\vspace{12pt}
	\centering
	\ra{1.3}
	\begin{tabularx}{\linewidth}{>{\centering}p{3cm} X}
		\toprule
		{\bfseries Requirement\newline Number} & \textbf{Description}\\
		\midrule
		DCMS-BBP-32 & {The BBP Simulator software shall support real-time (RT) execution whereby BBP FSW tasks are executed at the rate they would be on actual BBP hardware.}\\
		\midrule
		DCMS-BBP-53 & {The BBP Simulator software shall provide the capability to initialize, step, and terminate.}\\
		\midrule
		DCMS-BBP-122 & {The BBP Simulator software shall provide the capability to save the current state of the model to a file for later use as an initial configuration.}\\
		\midrule
		DCMS-BBP-56 & {The BBP Simulator software shall provide the capability to initialize to pre-defined FSW phase, states, and modes within 5 minutes.}\\
		\midrule
		DCMS-BBP-121 & {The BBP Simulator shall execute as a 64 bit process.}\\
		\bottomrule
	\end{tabularx}
	\caption{List of relevant customer requirements for the save \& restore feature of the \gls{BBPSim} system.}
	\label{tab:customer-reqs}
\end{table}

From the descriptions, it is possible to see that the above requirements have to do with \gls{BBPSim} as a whole, and not particularly with the save \& restore itself. Nonetheless, they were considered important to take into account. A proper overview of \gls{BBPSim} is given in \autoref{sec:bbpsim-charact}, where these requirements are further discussed in details.

\subsection*{User Requirements}

As mentioned earlier, a list of user requirements was also compiled beforehand, one that was applicable only to the checkpointing feature and thus would further guide the subject of this thesis. 

\begin{table}[htbp]
	\vspace{12pt}
	\centering
	\ra{1.3}
	\begin{tabularx}{\linewidth}{>{\centering}p{3cm} X}
		\toprule
		{\bfseries Requirement\newline Number} & \textbf{Description}\\
		\midrule
		U01 & {The save \& restore of the BBP Simulator software shall restore back a simulation state without stability issues on subsequent steps.}\\
		\midrule
		U02 & {The save \& restore of the BBP Simulator software shall be implemented without altering the flight software.}\\
		\midrule
		U03 & {A state file shall be the only required artifact to restore a BBP Simulator simulation.}\\
		\bottomrule
	\end{tabularx}
	\caption{List of user-imposed requirements for the save \& restore feature of the \gls{BBPSim} system.}
	\label{tab:user-reqs}
\end{table}

As it's possible to see in \autoref{tab:user-reqs}, one of the reason these requirements were chosen was to enforce a certain user-friendliness for both the customer and the verification and validation team. In that sense, requirements U01 and U03 focused on that goal: to make the feature easy to use, test and integrate within the V\&V environment. In particular, the inclusion of U03 was driven by the fact that a state file is much easier to manipulate programatically than a workspace or combination of files.

On top of that, the addition of requirement U02 was prompted by the added encapsulation of the task. In the end, adding in a feature to \gls{BBPSim} should not affect the flight software, even if the simulator is its testing framework. The FSW was to be taken as a "black box". Not altering the flight software meant that:
\begin{enumerate}
	\item The checkpoint/restore added code would be located in a single repository, decreasing maintenance costs.
	\item Only one piece of software had to be completely understood, decreasing ramp-up costs.
	\item Ultimately, much more content could be shared in this paper, because the flight software is regulated by stricter rules.
\end{enumerate}

\section{BBPSim Characteristics}\label{sec:bbpsim-charact}
Since the save \& restore feature relied on the existence of the \gls{BBPSim} simulator, it was important to first describe and understand the simulator in details before starting the design phase. For this reason, the present section further demonstrates the capabilities and the operation of \gls{BBPSim}, that served as constraints to the development of the feature.

\subsection*{Code Execution Environment}
As mentioned earlier in \autoref{sec:intro-background}, \gls{BBPSim} was ordered by \gls{SNC} to be part of a bigger, system-wide simulator called the \gls{DCMS}. In that regard, \gls{BBPSim} was delivered as a simple \pathmono{.so} file, bundled with its relevant headers. The \pathmono{.so} extension refers to the Linux shared object extension, more commonly known as a dynamic library. 

The usage of such an object is fairly straightforward. A Linux software developer wanting to make use of a dynamic library only has to link it with the \inlinecmd{-lLibraryName} flag when compiling its code with GCC. Because the library is already compiled, it also needs to provide "access points" to the functions, classes and types it publicly defines to the compiler. This is done with the help of header files, where the public API of the shared object is revealed. In their own programs, users of a certain dynamic library are only be able to see and use identifiers provided in the header files .

The rationale behind the use of a \pathmono{.so} file as the main delivery method by the Dream Chaser team was relatively simple:
\begin{itemize}
	\item It abstracted a lot of code by exposing only a subset of the identifiers to \gls{SNC}.
	\item Since the computer architecture in which the library executed was known in advance, it could be shipped precompiled in a package to the customer.
	\item Updating \gls{BBPSim} to a newer version didn't require \gls{SNC} to recompile its own massive \gls{DCMS} system as \gls{BBPSim}'s API didn't change between versions. See \autoref{sec:dynlib-considerations} for other  technical considerations of using a dynamic library.
\end{itemize}

In the context of the \gls{BBP} simulator, the code that was included in the library could be mainly divided in two parts: the flight software (also known as \gls{DAS}, written in C) and the \gls{BBPSim} environment (written in \Cpp). The source files from both domains were compiled for an x86 64-bit architecture and linked together to produce \pathmono{libBbpSim.so}.

\subsection*{Interaction Layers}
As mentioned earlier, the deliverable to the client had as a goal to provide a suitable environment for the simulated Dream Chaser flight software to be tested on a Linux machine. The two software domains had to co-exist so that a simulation done on said Linux computer would be \underline{functionally equivalent} to running the code on the actual embedded platform. 

As a design guideline, the Dream Chaser team implemented the \gls{BBPSim} environment in multiple layers that interface at different levels with the flight software. How those layers interact together is better shown in \autoref{fig:bbpsim-layers}, where \gls{DAS} is taken as the core component to which the other layers must adapt.

\begin{figure}[htbp]
	\vspace{12pt}
	\centering
	\includesvg[width=0.8\linewidth]{svg/bbpsim-layers}
	\caption{Placement of the different layers of the BBPSim environment in relation to the flight software and the OS}
	\label{fig:bbpsim-layers}
\end{figure}

The way the user communicates with a simulation is through the shared memory. This element of \gls{BBPSim} is the only freely exposed interface to the "outside world". Within the software-in-the-loop framework, the shared memory emulates the presence of hardware communication buses that are located on the embedded platform. It contains space allocated for several messages that are used for bi-directional communication between the user and the flight software. Each message, whether coming from DAS or the user, must be transmitted on one of the emulated bus interfaces of the real \gls{BBP} hardware (CAN, MIL-1553, Ethernet, Serial) and formatted accordingly.

In practice, the shared memory is implemented as a single block of user-provided memory, to which the hardware layer (HW) is given a reference. As an example, when the user wants to transmit a command to the flight software via the CAN bus, it must do so by first formatting the command to fit a CAN message, and then writing at the appropriate CAN bus offset within the shared memory. 

As for the HW layer, it emulates the hardware components and communication modules of the BBP by containing an implementation of the functionalities offered by the BBP in software. Even though the hardware layer technically incorporates the OS layer in \autoref{fig:bbpsim-layers}, it is useful to think of them as being separated for the rest of this thesis.

As stated before, the FSW code is written as if it was executed on an embedded platform. This is why routines in the flight software use the API of a \gls{RTOS} named DEOS, which provides vital embedded system functionalities like mutexes, semaphores, thread creation and scheduling, etc. This type of operating system is incompatible with a regular PC, due to both platforms being considerably different on multiple aspects. This is where the OS layer's role in the simulation becomes relevant. 

The OS layer reimplements all the DEOS functionalities used in DAS, but adapts the implementation to run on a regular Linux machine. It is, as a matter of principle, a "port" of the RTOS to Linux. For example, in a software-in-the-loop simulation, when the flight software wants to create a new thread, a Linux POSIX thread (pthread) is instead spawned by the layer. All the regular DEOS utilities are converted into their Linux equivalent. Additionally, more basic constructs that aren't OS-related, like FIFO queues, are also handled by this layer. \autoref{fig:bbpsim-layers} represents the operating system layer as being comprised inside the hardware layer. This is due to the OS layer being partially dependent on some hardware utilities that the HW layer provides.

In \autoref{sec:fsw-outline}, the interfacing and general interaction between the flight software and the HW and OS layers of BBPSim are explained in more details.

\subsection*{Commands}
While the shared memory layer of BBPSim offers a channel of communication by transfer of data to and from a running simulation, it is also important to understand how a user is able to control its execution. 

For this purpose, the design of BBPSim includes a set of commands that can be sent by the user. 
\begin{itemize}
	\item \textbf{INIT}. Basically initializes the simulation. This is where the user provides a reference to the shared memory block. All simulation modules inside the OS and hardware layers are constructed and initialized. If the user wants to restore a past simulation, it must provide the name of the relevant state file as a parameter. Only called once.
	\item \textbf{STEP}. Main command of BBPSim. When the user calls this command, BBPSim simulates 20ms of execution on the BBP hardware. In practice, it executes 1 control loop of each DAS thread sequentially, like in \autoref{fig:step-cmd}. After 1 loop, the threads of execution wait again for their turn on the next STEP. The order in which the threads are ran is determined in advance. Between two STEP commands, the user is allowed to change the content of the shared memory to send or read messages. \par
	\begin{minipage}{\linewidth}
		\vspace{12pt}
		\centering
		\includesvg[width=\linewidth]{svg/step-cmd}
		\captionof{figure}{Sequential execution of DAS threads in a STEP command}
		\label{fig:step-cmd}
		\vspace{12pt}
	\end{minipage}
	It is important to reiterate that this sequential execution must still guarantee an execution time that matches the one the hardware to satisfy requirement DCMS-BBP-32 (See \autoref{tab:customer-reqs}).
	\item \textbf{SAVE}. Saves the state of the simulation to file for a later restore. This is the subject of this thesis. 
	\item \textbf{TERM}. Terminates the simulation by stopping the waiting threads, freeing up allocated memory and tearing down the simulation modules. Only called once.
\end{itemize}
It is important to note that a command cannot be sent to BBPSim if the previous one hasn't finished. By extension, this means that \ul{when the user sends a SAVE command, every DAS thread alive within BBPSim is guaranteed to be in "standby", not executing any code}. 

Concretely, a simulation done with \pathmono{libBbpSim.so} is abstracted to an object. The above commands are sent by calling a member function and the shared memory can be written to or read from between commands.  \autoref{code:example-bbpsim-usage} shows a basic example of how to run a simulation from a user's perspective, and how he or she can manipulate the flight software, through the Shared Memory layer, to bring it in the wanted state.
\begin{listing}[H]
	\begin{minted}{c++}
SharedMemory* sm = new SharedMemory();
CBbpSim* bbpsim = new CBbpSim();
bbpsim->Init(sm);

while(!isFinished()) {
	sm->cantx[0] = NextCanMessage(); //Transmit a CAN message
	bbpsim->Step();
	ProcessCanResponse(sm->canrx[0]) //Read simulation CAN output
}

bbpsim->Term();
	\end{minted}
	\caption{Typical usage of a BBPSim simulation object using \pathmono{libBbpSim.so}'s API}
	\label{code:example-bbpsim-usage}
\end{listing}

\section{FSW Overview}\label{sec:fsw-outline}
Implementing and restoring the embedded software simulated inside \gls{BBPSim} required a comprehensive knowledge of what DAS looked like in source code. It was imperative to understand how it was structured to develop a good custom solution.  As part of the effort, this section describes the RTOS used as well as how the code was broken up into modules for better maintenance.

\subsection*{DEOS}
In \autoref{sec:bbpsim-charact}, the use of a real-time operating system in the flight software was briefly mentioned. Its inclusion in the project was vital for multiple reasons, embedded utilities being one of them. However, since Dream Chaser is a spacecraft project, performance standards in that area were heightened. This meant that not any embedded OS could be suitable and make guarantees about crucial parameters, like timing and responsiveness.

Even though DEOS isn't actually running inside the BBPSim environment, it is still very important to understand how its API works

time- and space-partitioned
could make guarantees about the stability and the execution
deos particularities with preemption
practically, how pthread, posix, they're used as wrapper for mutex in deos.
bbpsim re-implements hardware and software utilities.

\subsection{Modules}
- anatomy of the typical C module( static global, functions)
- anatomy of typical task loop in embedded systems 
}